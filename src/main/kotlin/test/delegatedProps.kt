package test.`delgated-props`

import kotlin.properties.Delegates
import kotlin.properties.PropertyDelegateProvider
import kotlin.properties.ReadOnlyProperty
import kotlin.properties.ReadWriteProperty
import kotlin.reflect.KProperty


fun main(){
    delegatedProps()
}

// https://kotlinlang.org/docs/delegated-properties.html#translation-rules-when-delegating-to-another-property

private fun delegatedProps(){

    // Delegated properties can appear everywhere
    val time by lazy { System.currentTimeMillis() }


    val t1 = Test()
    val t2 = Test()

    println(t1.lazyProp)
    println(t2.lazyProp)
    println(t1.lazyProp)
    println(t2.lazyProp)

    println(t1.observableProp)
    println(t2.observableProp)

    t1.observableProp = "t1 observable"
    t2.observableProp = "t2 observable"

    t1.vetoableProp = 2
    t2.vetoableProp = 11
    println(t1.vetoableProp)
    println(t2.vetoableProp)

    t1.customVarPropLoggerDelegate
    t1.customVarPropLoggerDelegate = "new value"

    println(t1.intProvidedByLibrary)
}



// Types of delegated properties can be inferred

private class Test{

    // Lazy: lazy initialization by provided function
    // only for vals
    val lazyProp: Long by lazy { System.currentTimeMillis() }

    // Observable: provided function is called AFTER assignment
    var observableProp by Delegates.observable("observable initial value"){
        kProp, old, new -> println("$old -> $new")
    }

    // Vetoable: provided function is called BEFORE assignment and can cancel assignment operation
    var vetoableProp by Delegates.vetoable(4){
        kProp, old, new ->
        println("$old try into $new")
        new in 1..10 // allow ints only in [1;10] range
    }

    // delegate this property getter & setter to another property
    var delegatedProp by ::originalProp

    // custom val delegate using object
    val customValDelegate by valDelegate()

    // custom var delegate using object
    var customVarDelegate by varDelegate()

    var customVarPropLoggerDelegate by PropLogger("initial value")

    val intProvidedByLibrary by intProvider
}

@Deprecated("Use 'Test::delegatedProp' instead", ReplaceWith("originalProp"))
private var originalProp = "prop"



// Storing properties into a map - backing field for properties are located as map entries
// you can use var & MutableMap
private class User(val map: Map<String, Any?>) {
    val name: String by map
    val age: Int     by map
}
// In this example, the constructor takes a map:
private val user = User(mapOf(
    "name" to "John Doe",
    "age"  to 25
))




// Каждый вызов функции возвращает уникальный анонимный объект,
// так же можно создать и класс, а потом его экземпляры как объекты.
// Можно не создавать backing field для хранения значения, если это не требуется.

// Delegate property as object
private fun valDelegate() = object : ReadOnlyProperty<Any?,Long>{
    var accessTime = null as Long? // this is backing field
    override fun getValue(thisRef: Any?, property: KProperty<*>): Long {
        return accessTime ?: System.currentTimeMillis().let { accessTime = it; it }
    }
}
private fun varDelegate() = object : ReadWriteProperty<Any?, Char> {
    var charCode = 0 // this is backing field
    override fun getValue(thisRef: Any?, property: KProperty<*>): Char {
        return charCode.toChar()
    }
    override fun setValue(thisRef: Any?, property: KProperty<*>, value: Char) {
        charCode = value.code
    }
}

/*
    Что происходит при делегировании объекту:

    // Написанный код:
    class C {
        var prop: Type by MyDelegate()
    }

    // this code is generated by the compiler instead:
    // сам объект сохраняется в скрытую переменную, prop становится псевдосвойством и делегирует всё объекту
    class C {
        private val prop$delegate = MyDelegate()
        var prop: Type
            get() = prop$delegate.getValue(this, this::prop)
            set(value: Type) = prop$delegate.setValue(this, this::prop, value)
    }
 */

private class PropLogger<V : Any?>(var backingField: V) : ReadWriteProperty<Any?, V> {
    // getValue(<this class instance ref (in which property is)>, <delegated property ref>)
    override operator fun getValue(thisRef: Any?, property: KProperty<*>): V {
        println("GET delegated property '${property.name}'='$backingField' inside $thisRef")
        return backingField
    }

    // getValue(<this class instance ref (in which property is)>, <delegated property ref>, <new value>)
    override fun setValue(thisRef: Any?, property: KProperty<*>, value: V) {
        println("SET delegated property '${property.name}' '$backingField' to '$value' inside $thisRef")
        backingField = value
    }
}







/*

class Image
class Text
enum class ResourceID{ imageId, textId }

class ResourceDelegateByName<T> : ReadOnlyProperty<MyUI, T> {
    override fun getValue(thisRef: MyUI, property: KProperty<*>): T {
        return "some resource value"
    }
}
class ResourceLoader<T>(id: ResourceID<T>){

}
class MyUI {

}

*/






// Using embed functions to create delegated property
val intProvider = PropertyDelegateProvider { thisRef: Any?, property ->
    ReadOnlyProperty<Any?, Int> { _, property -> 42 }
}






